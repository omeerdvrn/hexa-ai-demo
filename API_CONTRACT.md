# API Contract - Logo Generation Job Flow

This document defines the complete contract between frontend and backend for logo generation jobs, including all state transitions, failure scenarios, and testing methods.

## Frontend Initiates Job

### Initial Job Document Creation

**What Frontend Writes:**

```javascript
const jobData = {
  id: string, // Auto-generated by Firestore
  userId: string, // Current authenticated user ID
  type: "logo", // Job type (currently only "logo" supported)
  status: "processing", // Initial status
  prompt: string, // User's text input (1-200 characters)
  style: number, // Selected style index (0-3)
  seen: false, // Whether user has viewed result
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
  resultUrl: null, // Will be set by backend
  error: null, // Will be set by backend on failure
};
```

**Frontend Call Pattern:**

```javascript
// From useJobManager.js
const createAndSubscribeToJob = async (jobData) => {
  // 1. Create job document
  const newJobId = await createJob(userId, {
    prompt: "modern tech startup logo",
    style: 2,
    type: "logo",
  });

  // 2. Immediately subscribe to real-time updates
  const unsubscribe = subscribeToJob(newJobId, (jobUpdate) => {
    // Handle status changes in real-time
    setProgressData(jobUpdate);
  });

  return newJobId;
};
```

## Backend Processing Pipeline

### 1. Firestore Trigger Activation

**Trigger:** `@firestore_fn.on_document_created(document="jobs/{job_id}")`

**What Happens:**

- Cloud Function automatically triggered when job document created
- Receives job data and job ID from Firestore event
- Initiates `JobService.process_job()` pipeline

### 2. Validation Phase

**Backend Validates:**

```python
def validate_job_data(job_data):
    # Required fields check
    if not job_data.get("prompt"):
        return False, "Missing prompt"

    if not job_data.get("userId"):
        return False, "Missing userId"

    # Job type validation
    job_type = job_data.get("type")
    if job_type and job_type != "logo":
        return False, f"Unsupported job type: {job_type}"

    return True, None
```

**If Validation Fails:**

```javascript
// Backend updates job document
{
  status: "failed",
  error: "Missing prompt" | "Missing userId" | "Unsupported job type: {type}",
  updatedAt: serverTimestamp()
}
```

### 3. Image Generation Phase

**Process:**

```python
def generate_mock_image_url(job_id, prompt):
    # 1. Calculate processing time (5-45 seconds based on prompt complexity)
    processing_time = 5 + min(len(prompt) / 10, 30) + random(0, 20)
    time.sleep(processing_time)

    # 2. Simulate 30% failure rate for testing
    if random(1, 10) < 3:
        raise Exception("AI generation failed")

    # 3. Generate deterministic image URL
    seed = hashlib.md5(f"{job_id}-{prompt}".encode()).hexdigest()[:10]
    return f"https://picsum.photos/seed/{seed}/400/400"
```

**If Generation Fails:**

```javascript
// Backend updates job document
{
  status: "failed",
  error: "AI generation failed" | "Logo generation pipeline failed: {details}",
  updatedAt: serverTimestamp()
}
```

### 4. Storage Upload Phase

**Process:**

```python
def store_image_from_url(image_url, job_id):
    # 1. Download image from generated URL
    response = requests.get(image_url, timeout=30)

    # 2. Upload to Firebase Storage
    bucket = storage.bucket()
    blob_path = f"logos/{job_id}.png"
    blob.upload_from_string(image_data, content_type="image/png")
    blob.make_public()

    # 3. Generate public URL
    public_url = f"https://storage.googleapis.com/{bucket.name}/{blob_path}"
    return {"resultUrl": public_url, "error": None}
```

**If Upload Fails:**

```javascript
// Backend updates job document
{
  status: "failed",
  error: "Failed to download image: {details}" | "Failed to upload image: {details}",
  updatedAt: serverTimestamp()
}
```

### 5. Success Completion

**Backend Updates on Success:**

```javascript
// 1. Update job document
{
  status: "completed",
  resultUrl: "https://storage.googleapis.com/bucket-name/logos/{job_id}.png",
  updatedAt: serverTimestamp()
}

// 2. Create logo document
{
  id: string,              // Auto-generated
  jobId: string,           // Reference to job
  userId: string,          // User ID from job
  prompt: string,          // Prompt from job
  style: number,           // Style from job
  storageUrl: string,      // Same as job.resultUrl
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp()
}
```

## Status Transitions

| Current Status | Next Status  | Trigger                 | Backend Action                  |
| -------------- | ------------ | ----------------------- | ------------------------------- |
| N/A            | `processing` | Job created by frontend | Firestore trigger activates     |
| `processing`   | `failed`     | Validation error        | Set error message               |
| `processing`   | `failed`     | Generation failure      | Set error message               |
| `processing`   | `failed`     | Upload failure          | Set error message               |
| `processing`   | `completed`  | Success pipeline        | Set resultUrl + create logo doc |

**Important Notes:**

- No status can transition back to `processing`
- `completed` and `failed` are terminal states
- Frontend never writes to `status`, `resultUrl`, or `error` fields

## Status Meanings

| Status       | Description                            | Frontend Behavior                                      | User Experience                     |
| ------------ | -------------------------------------- | ------------------------------------------------------ | ----------------------------------- |
| `processing` | Job is being processed by backend      | Shows loading indicator with "Creating Your Design..." | User waits, sees progress animation |
| `completed`  | Logo successfully generated and stored | Shows "Your Design is Ready!" with preview             | User can tap to view full result    |
| `failed`     | Generation failed at any stage         | Shows "Oops, something went wrong!"                    | User can retry by tapping           |

## Failure Scenarios & Testing

### 1. Validation Failures

**How to Produce:**

```javascript
// Missing prompt
await createJob(userId, { style: 1 });
// Expected: status="failed", error="Missing prompt"

// Invalid job type
await createJob(userId, { prompt: "test", type: "image" });
// Expected: status="failed", error="Unsupported job type: image"

// Missing userId (edge case)
jobService.createJob(null, { prompt: "test" });
// Expected: status="failed", error="Missing userId"
```

### 2. Generation Failures (Simulated ~30% rate)

**How to Produce:**

```javascript
// Keep creating jobs until one fails
const testGenerationFailure = async () => {
  for (let i = 0; i < 10; i++) {
    const jobId = await createJob(userId, {
      prompt: `test prompt ${i}`,
      style: 0,
    });
    // Wait and check if status becomes "failed"
    // Expected: ~3 out of 10 will fail with "AI generation failed"
  }
};
```

### 3. Network/Upload Failures

**How to Produce:**

- Temporarily disable Firebase Storage
- Use invalid storage credentials
- Network connectivity issues during image download

**Expected Results:**

```javascript
{
  status: "failed",
  error: "Failed to download image: timeout" | "Failed to upload image: permission denied"
}
```

### 4. Real-time Subscription Edge Cases

**Frontend Subscription Handling:**

```javascript
const subscribeToJob = (jobId, callback) => {
  return onSnapshot(
    jobRef,
    (doc) => {
      if (doc.exists()) {
        callback({ id: doc.id, ...doc.data() });
      } else {
        callback(null); // Job deleted
      }
    },
    (error) => {
      callback(null, error); // Connection error
    },
  );
};
```

**How to Test:**

```javascript
// Test connection loss
// 1. Start job
// 2. Disconnect internet
// 3. Reconnect
// Expected: Subscription resumes, shows correct status

// Test rapid status changes
// Expected: Frontend receives all intermediate updates
```

## Error Recovery Patterns

### User-Initiated Retry

```javascript
const retryLastJob = async () => {
  // 1. Get last job data
  const lastJob = await getLatestJob(userId);

  // 2. Create new job with same parameters
  return await createAndSubscribeToJob({
    prompt: lastJob.prompt,
    style: lastJob.style,
  });
};
```

### Automatic Cleanup

```javascript
// Frontend cleans up subscriptions on component unmount
useEffect(() => {
  return () => {
    if (unsubscribeRef.current) {
      unsubscribeRef.current(); // Prevent memory leaks
    }
  };
}, []);
```

## Performance Characteristics

- **Expected Processing Time:** 5-45 seconds (based on prompt complexity)
- **Failure Rate:** ~30% (for testing realistic error handling)
- **Concurrent Jobs:** Limited to 1 per user (enforced by frontend)
- **Storage Path:** `logos/{job_id}.png` in Firebase Storage
- **Image Format:** PNG, 400x400 pixels
